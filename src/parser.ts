
// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.6 )
//
// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs

"use strict";

// @ts-ignore
import stripIndent from 'strip-indent';
import { ASTKind, OperationType, node } from './ast';
export interface IFilePosition {
  offset: number;
  line: number;
  column: number;
}

export interface IFileRange {
  start: IFilePosition;
  end: IFilePosition;
}

export interface ILiteralExpectation {
  type: "literal";
  text: string;
  ignoreCase: boolean;
}

export interface IClassParts extends Array<string | IClassParts> {}

export interface IClassExpectation {
  type: "class";
  parts: IClassParts;
  inverted: boolean;
  ignoreCase: boolean;
}

export interface IAnyExpectation {
  type: "any";
}

export interface IEndExpectation {
  type: "end";
}

export interface IOtherExpectation {
  type: "other";
  description: string;
}

export type Expectation = ILiteralExpectation | IClassExpectation | IAnyExpectation | IEndExpectation | IOtherExpectation;

export class SyntaxError extends Error {
  public static buildMessage(expected: Expectation[], found: string | null) {
    function hex(ch: string): string {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s: string): string {
      return s
        .replace(/\\/g, "\\\\")
        .replace(/"/g,  "\\\"")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,            (ch) => "\\x0" + hex(ch) )
        .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x"  + hex(ch) );
    }

    function classEscape(s: string): string {
      return s
        .replace(/\\/g, "\\\\")
        .replace(/\]/g, "\\]")
        .replace(/\^/g, "\\^")
        .replace(/-/g,  "\\-")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,            (ch) => "\\x0" + hex(ch) )
        .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x"  + hex(ch) );
    }

    function describeExpectation(expectation: Expectation) {
      switch (expectation.type) {
        case "literal":
          return "\"" + literalEscape(expectation.text) + "\"";
        case "class":
          const escapedParts = expectation.parts.map((part) => {
            return Array.isArray(part)
              ? classEscape(part[0] as string) + "-" + classEscape(part[1] as string)
              : classEscape(part);
          });

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }

    function describeExpected(expected1: Expectation[]) {
      const descriptions = expected1.map(describeExpectation);
      let i: number;
      let j: number;

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found1: string | null) {
      return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }

  public message: string;
  public expected: Expectation[];
  public found: string | null;
  public location: IFileRange;
  public name: string;

  constructor(message: string, expected: Expectation[], found: string | null, location: IFileRange) {
    super();
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";

    if (typeof (Error as any).captureStackTrace === "function") {
      (Error as any).captureStackTrace(this, SyntaxError);
    }
  }
}

function peg$parse(input: string, options?: IParseOptions) {
  options = options !== undefined ? options : {};

  const peg$FAILED: Readonly<{}> = {};

  const peg$startRuleIndices: {[id: string]: number}  = { start: 0 };
  let peg$startRuleIndex = 0;

  const peg$consts = [
    peg$anyExpectation(),
    /^[\n\r]/,
    peg$classExpectation(["\n", "\r"], false, false),
    peg$otherExpectation("end of line"),
    "\n",
    peg$literalExpectation("\n", false),
    "\r\n",
    peg$literalExpectation("\r\n", false),
    "\r",
    peg$literalExpectation("\r", false),
    "u",
    peg$literalExpectation("u", false),
    /^[0-9a-f]/i,
    peg$classExpectation([["0", "9"], ["a", "f"]], false, true),
    function(digits: any): any {
          return String.fromCharCode(parseInt(digits, 16));
        },
    "\"",
    peg$literalExpectation("\"", false),
    "\\",
    peg$literalExpectation("\\", false),
    "/",
    peg$literalExpectation("/", false),
    "b",
    peg$literalExpectation("b", false),
    function(): any { return "\b"; },
    "f",
    peg$literalExpectation("f", false),
    function(): any { return "\f"; },
    "n",
    peg$literalExpectation("n", false),
    function(): any { return "\n"; },
    "r",
    peg$literalExpectation("r", false),
    function(): any { return "\r"; },
    "t",
    peg$literalExpectation("t", false),
    function(): any { return "\t"; },
    "v",
    peg$literalExpectation("v", false),
    function(): any { return "\v"; },
    function(): any { return text(); },
    /^[_A-Za-z]/,
    peg$classExpectation(["_", ["A", "Z"], ["a", "z"]], false, false),
    /^[_0-9A-Za-z]/,
    peg$classExpectation(["_", ["0", "9"], ["A", "Z"], ["a", "z"]], false, false),
    function(head: any, tail: any): any { return head + tail.join('') },
    function(name: any): any { return node(ASTKind.Name, name) },
    "#",
    peg$literalExpectation("#", false),
    /^[^\n\r]/,
    peg$classExpectation(["\n", "\r"], true, false),
    "!",
    peg$literalExpectation("!", false),
    function(name: any, n: any): any { return node(ASTKind.NamedType, name, n ? 1 : 0)},
    "[",
    peg$literalExpectation("[", false),
    "]",
    peg$literalExpectation("]", false),
    function(t: any, n: any): any { return node(ASTKind.ListType, t,  n ? 1 : 0) },
    "true",
    peg$literalExpectation("true", false),
    "false",
    peg$literalExpectation("false", false),
    function(value: any): any {
      return node(ASTKind.BooleanValue, Boolean(value))
    },
    "null",
    peg$literalExpectation("null", false),
    function(): any { return node(ASTKind.NullValue)},
    function(name: any): any { return node(ASTKind.EnumValue, name)},
    function(sequence: any): any { return sequence; },
    peg$otherExpectation("BlockStringCharactor"),
    "\"\"\"",
    peg$literalExpectation("\"\"\"", false),
    peg$otherExpectation("string"),
    function(chars: any): any {
        return node(ASTKind.StringValue, stripIndent(chars.join('')).trim())
      },
    function(chars: any): any {  return node(ASTKind.StringValue, chars.join(''))  },
    "-",
    peg$literalExpectation("-", false),
    "0",
    peg$literalExpectation("0", false),
    /^[1-9]/,
    peg$classExpectation([["1", "9"]], false, false),
    /^[0-9]/,
    peg$classExpectation([["0", "9"]], false, false),
    ".",
    peg$literalExpectation(".", false),
    "e",
    peg$literalExpectation("e", false),
    "E",
    peg$literalExpectation("E", false),
    "+",
    peg$literalExpectation("+", false),
    function(frac: any): any {
        return frac != null ?
          node(ASTKind.FloatValue, parseFloat(text())) :
          node(ASTKind.IntValue, parseInt(text(), 10))
      },
    ":",
    peg$literalExpectation(":", false),
    function(name: any, value: any): any {
        return node(ASTKind.ObjectField, name, value)
      },
    "{",
    peg$literalExpectation("{", false),
    function(p: any): any { return p },
    "}",
    peg$literalExpectation("}", false),
    function(values: any): any {
      	return node(ASTKind.ObjectField, values)
      },
    function(v: any): any { return v },
    function(values: any): any {
        return node(ASTKind.ListValue, values)
      },
    "=",
    peg$literalExpectation("=", false),
    "$",
    peg$literalExpectation("$", false),
    function(n: any): any { return node(ASTKind.Variable, n) },
    function(variable: any, type: any, dflt: any): any {
        return node(ASTKind.VariableDefinition, variable, type, dflt)
      },
    "(",
    peg$literalExpectation("(", false),
    ")",
    peg$literalExpectation(")", false),
    function(vars: any): any { return vars },
    function(name: any, value: any): any { return node(ASTKind.Argument, name, value) },
    function(arg: any): any { return arg },
    function(args: any): any { return args },
    function(alias: any): any { return alias },
    function(alias: any, name: any, args: any, d: any, s: any): any {
        return node(ASTKind.Field, alias, name, args, d, s)
      },
    function(f: any): any { return f },
    function(fields: any): any {
      	return node(ASTKind.SelectionSet, fields)
      },
    "query",
    peg$literalExpectation("query", false),
    function(): any { return OperationType.query },
    "mutation",
    peg$literalExpectation("mutation", false),
    function(): any { return OperationType.mutation },
    "subscription",
    peg$literalExpectation("subscription", false),
    function(): any { return OperationType.subscription },
    function(type: any, name: any, vars: any, d: any, s: any): any {
        return node(ASTKind.OperationDefinition, type, name, vars, d, s)
      },
    function(s: any): any {
        return node(ASTKind.OperationDefinition, OperationType.query, null, null, null, s)
      },
    "on",
    peg$literalExpectation("on", false),
    function(type: any): any { return type },
    "@",
    peg$literalExpectation("@", false),
    function(n: any, a: any): any { return node(ASTKind.Directive, n, a) },
    function(d: any): any { return d },
    "fragment",
    peg$literalExpectation("fragment", false),
    function(name: any, type: any, d: any, s: any): any {
    	return node(ASTKind.FragmentDefinition, name, null, type, d, s)
      },
    "...",
    peg$literalExpectation("...", false),
    function(name: any, d: any): any {
    	  return node(ASTKind.FragmentSpread, name, d)
      },
    function(type: any, d: any, s: any): any {
    	  return node(ASTKind.InlineFragment, type, d, s)
      },
    function(ot: any, nt: any): any {
        return node(ASTKind.OperationTypeDefinition, ot, nt)
      },
    function(defs: any): any {
        return defs
      },
    "schema",
    peg$literalExpectation("schema", false),
    function(description: any, directives: any, defs: any): any {
        return node(ASTKind.SchemaDefinition, description, directives, defs)
      },
    "scalar",
    peg$literalExpectation("scalar", false),
    function(description: any, name: any, directives: any): any {
          node(ASTKind.ScalarTypeDefinition, description, name, directives)
        },
    "union",
    peg$literalExpectation("union", false),
    function(description: any, name: any, directives: any, members: any): any {
          return node(ASTKind.UnionTypeDefinition, description, name, directives, members)
        },
    "|",
    peg$literalExpectation("|", false),
    function(t: any): any { return t },
    function(head: any, tail: any): any {
          return [head].concat(tail)
        },
    "enum",
    peg$literalExpectation("enum", false),
    function(description: any, name: any, directives: any, values: any): any {
          return node(ASTKind.EnumTypeDefinition, description, name, directives, values)
        },
    function(defs: any): any {
          return defs
        },
    function(description: any, name: any, directives: any): any {
          return node(ASTKind.EnumValueDefinition, description, name, directives)
        },
    "type",
    peg$literalExpectation("type", false),
    function(description: any, name: any, impls: any, directives: any, fields: any): any {
          return node(ASTKind.ObjectTypeDefinition, description, name, impls, directives, fields)
        },
    "interface",
    peg$literalExpectation("interface", false),
    function(description: any, name: any, impls: any, directives: any, fields: any): any {
          return node(ASTKind.InterfaceTypeDefinition, description, name, impls, directives, fields)
        },
    function(description: any, name: any, args: any, type: any, directives: any): any {
          return node(ASTKind.FieldDefinition, description, name, args, type, directives)
        },
    function(fields: any): any { return fields },
    function(description: any, name: any, type: any, defaultValue: any, directives: any): any {
          return node(ASTKind.InputValueDefinition, description, name, type, defaultValue, directives)
        },
    "&",
    peg$literalExpectation("&", false),
    "implements",
    peg$literalExpectation("implements", false),
    "input",
    peg$literalExpectation("input", false),
    function(description: any, name: any, directives: any, fields: any): any {
          return node(ASTKind.InputObjectTypeDefinition, description, name, directives, fields)
        },
    "directive",
    peg$literalExpectation("directive", false),
    "repeatable",
    peg$literalExpectation("repeatable", false),
    function(description: any, name: any, args: any, r: any, locations: any): any {
          return node(ASTKind.DirectiveDefinition, description, name, args, r ? 1 : 0, locations)
        },
    "QUERY",
    peg$literalExpectation("QUERY", false),
    "MUTATION",
    peg$literalExpectation("MUTATION", false),
    "SUBSCRIPTION",
    peg$literalExpectation("SUBSCRIPTION", false),
    "FIELD",
    peg$literalExpectation("FIELD", false),
    "FRAGMENT_DEFINITION",
    peg$literalExpectation("FRAGMENT_DEFINITION", false),
    "FRAGMENT_SPREAD",
    peg$literalExpectation("FRAGMENT_SPREAD", false),
    "INLINE_FRAGMENT",
    peg$literalExpectation("INLINE_FRAGMENT", false),
    "VARIABLE_DEFINITION",
    peg$literalExpectation("VARIABLE_DEFINITION", false),
    "SCHEMA",
    peg$literalExpectation("SCHEMA", false),
    "SCALAR",
    peg$literalExpectation("SCALAR", false),
    "OBJECT",
    peg$literalExpectation("OBJECT", false),
    "FIELD_DEFINITION",
    peg$literalExpectation("FIELD_DEFINITION", false),
    "ARGUMENT_DEFINITION",
    peg$literalExpectation("ARGUMENT_DEFINITION", false),
    "INTERFACE",
    peg$literalExpectation("INTERFACE", false),
    "UNION",
    peg$literalExpectation("UNION", false),
    "ENUM",
    peg$literalExpectation("ENUM", false),
    "ENUM_VALUE",
    peg$literalExpectation("ENUM_VALUE", false),
    "INPUT_OBJECT",
    peg$literalExpectation("INPUT_OBJECT", false),
    "INPUT_FIELD_DEFINITION",
    peg$literalExpectation("INPUT_FIELD_DEFINITION", false),
    "extend",
    peg$literalExpectation("extend", false),
    function(directives: any, defs: any): any {
          return node(ASTKind.SchemaExtension, directives, defs)
        },
    function(directives: any): any {
          return  node(ASTKind.SchemaExtension, directives, null)
        },
    function(name: any, directives: any): any {
          return node(ASTKind.ScalarTypeExtension, name, directives)
        },
    function(name: any, impls: any, directives: any, fields: any): any {
          return node(ASTKind.ObjectTypeExtension, name, impls, directives, fields)
        },
    function(name: any, impls: any, directives: any): any {
          return node(ASTKind.ObjectTypeExtension, name, impls, directives, null)
        },
    function(name: any, impls: any): any {
          return node(ASTKind.ObjectTypeExtension, name, impls, null, null)
        },
    function(name: any, impls: any, directives: any, fields: any): any {
          return node(ASTKind.InterfaceTypeExtension, name, impls, directives, fields)
        },
    function(name: any, impls: any, directives: any): any {
          return node(ASTKind.InterfaceTypeExtension, name, impls, directives, null)
        },
    function(name: any, impls: any): any {
          return node(ASTKind.InterfaceTypeExtension, name, impls, null, null)
        },
    function(name: any, directives: any, members: any): any {
          return node(ASTKind.UnionTypeExtension, name, directives, members)
        },
    function(name: any, directives: any): any {
          return node(ASTKind.UnionTypeExtension, name, directives, null)
        },
    function(name: any, directives: any, values: any): any {
          return node(ASTKind.EnumTypeExtension, name, directives, values)
        },
    function(name: any, directives: any): any {
          return node(ASTKind.EnumTypeExtension, name, directives, null)
        },
    function(name: any, directives: any, fields: any): any {
           return node(ASTKind.InputObjectTypeExtension, name, directives, fields)
        },
    function(name: any, directives: any): any {
          return node(ASTKind.InputObjectTypeExtension, name, directives, null)
        },
    function(def: any): any { return def },
    function(ops: any): any {
        return node(ASTKind.Document, ops)
      },
    /^[_a-zA-Z0-9]/,
    peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
    /^[ \t,]/,
    peg$classExpectation([" ", "\t", ","], false, false),
    peg$otherExpectation("whitespace"),
    /^[ \t\n\r,]/,
    peg$classExpectation([" ", "\t", "\n", "\r", ","], false, false)
  ];

  const peg$bytecode = [
    peg$decode(";r"),
    peg$decode("1\"\"5!7 "),
    peg$decode("4!\"\"5!7\""),
    peg$decode("<2$\"\"6$7%.5 &2&\"\"6&7'.) &2(\"\"6(7)=.\" 7#"),
    peg$decode(";%.# &;&.\x85 &%2*\"\"6*7+/u#%%4,\"\"5!7-/P#4,\"\"5!7-/A$4,\"\"5!7-/2$4,\"\"5!7-/#$+$)($'#(#'#(\"'#&'#/\"!&,)/($8\":.\"! )(\"'#&'#"),
    peg$decode("2/\"\"6/70.\xCB &21\"\"6172.\xBF &23\"\"6374.\xB3 &2*\"\"6*7+.\xA7 &%25\"\"6576/& 8!:7! ).\x90 &%28\"\"6879/& 8!::! ).y &%2;\"\"6;7</& 8!:=! ).b &%2>\"\"6>7?/& 8!:@! ).K &%2A\"\"6A7B/& 8!:C! ).4 &%2D\"\"6D7E/& 8!:F! )"),
    peg$decode("%%<;%.# &;\"=.##&&!&'#/0#;!/'$8\":G\" )(\"'#&'#"),
    peg$decode("%4H\"\"5!7I/E#$4J\"\"5!7K0)*4J\"\"5!7K&/)$8\":L\"\"! )(\"'#&'#"),
    peg$decode("%;'/' 8!:M!! )"),
    peg$decode("%2N\"\"6N7O/H#$4P\"\"5!7Q0)*4P\"\"5!7Q&/,$;#/#$+#)(#'#(\"'#&'#"),
    peg$decode("%;'/=#2R\"\"6R7S.\" &\"/)$8\":T\"\"! )(\"'#&'#"),
    peg$decode("%2U\"\"6U7V/g#;v/^$;,/U$;v/L$2W\"\"6W7X/=$2R\"\"6R7S.\" &\"/)$8&:Y&\"# )(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";*.# &;+"),
    peg$decode(";6.G &;7.A &;..; &;/.5 &;4./ &;3.) &;0.# &;9"),
    peg$decode("%%2Z\"\"6Z7[/,#;s/#$+\")(\"'#&'#.< &%2\\\"\"6\\7]/,#;s/#$+\")(\"'#&'#/' 8!:^!! )"),
    peg$decode("%2_\"\"6_7`/0#;s/'$8\":a\" )(\"'#&'#"),
    peg$decode("%%<;..# &;/=.##&&!&'#/1#;'/($8\":b\"! )(\"'#&'#"),
    peg$decode("%%<2/\"\"6/70./ &21\"\"6172.# &;\"=.##&&!&'#/0#;!/'$8\":G\" )(\"'#&'#.A &%21\"\"6172/1#;$/($8\":c\"! )(\"'#&'#"),
    peg$decode("<%%<2e\"\"6e7f.) &21\"\"6172=.##&&!&'#/0#;!/'$8\":G\" )(\"'#&'#.A &%21\"\"6172/1#;$/($8\":c\"! )(\"'#&'#=.\" 7d"),
    peg$decode("<%2e\"\"6e7f/G#$;20#*;2&/7$2e\"\"6e7f/($8#:h#!!)(#'#(\"'#&'#.W &%2/\"\"6/70/G#$;10#*;1&/7$2/\"\"6/70/($8#:i#!!)(#'#(\"'#&'#=.\" 7g"),
    peg$decode("%2j\"\"6j7k.\" &\"/\u0115#2l\"\"6l7m.O &%4n\"\"5!7o/?#$4p\"\"5!7q0)*4p\"\"5!7q&/#$+\")(\"'#&'#/\xD4$%2r\"\"6r7s/E#$4p\"\"5!7q/,#0)*4p\"\"5!7q&&&#/#$+\")(\"'#&'#.\" &\"/\x94$%2t\"\"6t7u.) &2v\"\"6v7w/e#2x\"\"6x7y.) &2j\"\"6j7k.\" &\"/E$$4p\"\"5!7q/,#0)*4p\"\"5!7q&&&#/#$+#)(#'#(\"'#&'#.\" &\"/($8$:z$!!)($'#(#'#(\"'#&'#"),
    peg$decode("%;(/S#;v/J$2{\"\"6{7|/;$;v/2$;-/)$8%:}%\"$ )(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2~\"\"6~7\x7F/\x89#$%;v/:#;5/1$;v/($8#:\x80#!!)(#'#(\"'#&'#0D*%;v/:#;5/1$;v/($8#:\x80#!!)(#'#(\"'#&'#&/7$2\x81\"\"6\x817\x82/($8#:\x83#!!)(#'#(\"'#&'#"),
    peg$decode("%2U\"\"6U7V/\x89#$%;v/:#;-/1$;v/($8#:\x84#!!)(#'#(\"'#&'#0D*%;v/:#;-/1$;v/($8#:\x84#!!)(#'#(\"'#&'#&/7$2W\"\"6W7X/($8#:\x85#!!)(#'#(\"'#&'#"),
    peg$decode("%2\x86\"\"6\x867\x87/:#;v/1$;-/($8#:\x84#! )(#'#(\"'#&'#"),
    peg$decode("%2\x88\"\"6\x887\x89/1#;'/($8\":\x8A\"! )(\"'#&'#"),
    peg$decode("%;9/b#2{\"\"6{7|/S$;v/J$;,/A$;v/8$;8.\" &\"/*$8&:\x8B&#%\" )(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\x8C\"\"6\x8C7\x8D/\x98#$%;v/:#;:/1$;v/($8#:\x84#!!)(#'#(\"'#&'#/G#0D*%;v/:#;:/1$;v/($8#:\x84#!!)(#'#(\"'#&'#&&&#/@$;v/7$2\x8E\"\"6\x8E7\x8F/($8$:\x90$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;v/e#;(/\\$;v/S$2{\"\"6{7|/D$;v/;$;-/2$;v/)$8':\x91'\"%!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\x8C\"\"6\x8C7\x8D/\x92#$%;v/:#;</1$;v/($8#:\x92#!!)(#'#(\"'#&'#0D*%;v/:#;</1$;v/($8#:\x92#!!)(#'#(\"'#&'#&/@$;v/7$2\x8E\"\"6\x8E7\x8F/($8$:\x93$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;(/@#;v/7$2{\"\"6{7|/($8#:\x94#!\")(#'#(\"'#&'#"),
    peg$decode("%;>.\" &\"/\x83#;v/z$;(/q$;v/h$;=.\" &\"/Z$;v/Q$;F.\" &\"/C$;v/:$;A.\" &\"/,$8):\x95)%(&$\" )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";?.) &;I.# &;H"),
    peg$decode("%2~\"\"6~7\x7F/\x89#$%;v/:#;@/1$;v/($8#:\x96#!!)(#'#(\"'#&'#0D*%;v/:#;@/1$;v/($8#:\x96#!!)(#'#(\"'#&'#&/7$2\x81\"\"6\x817\x82/($8#:\x97#!!)(#'#(\"'#&'#"),
    peg$decode("%2\x98\"\"6\x987\x99/& 8!:\x9A! ).K &%2\x9B\"\"6\x9B7\x9C/& 8!:\x9D! ).4 &%2\x9E\"\"6\x9E7\x9F/& 8!:\xA0! )"),
    peg$decode("%;v/\x8C#;B/\x83$;v/z$;(.\" &\"/l$;v/c$;;.\" &\"/U$;v/L$;F.\" &\"/>$;v/5$;A/,$8*:\xA1*%(&$\" )(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.; &%;v/1#;A/($8\":\xA2\"! )(\"'#&'#"),
    peg$decode("%2\xA3\"\"6\xA37\xA4/:#;v/1$;*/($8#:\xA5#! )(#'#(\"'#&'#"),
    peg$decode("%2\xA6\"\"6\xA67\xA7/I#;(/@$;v/7$;=.\" &\"/)$8$:\xA8$\"\" )($'#(#'#(\"'#&'#"),
    peg$decode("$%;E/1#;v/($8\":\xA9\"!!)(\"'#&'#0;*%;E/1#;v/($8\":\xA9\"!!)(\"'#&'#&"),
    peg$decode("%2\xAA\"\"6\xAA7\xAB/x#;v/o$;(/f$;v/]$;D/T$;v/K$;F.\" &\"/=$;v/4$;A/+$8):\xAC)$&$\" )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\xAD\"\"6\xAD7\xAE/R#;v/I$;(/@$;v/7$;F.\" &\"/)$8%:\xAF%\"\" )(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\xAD\"\"6\xAD7\xAE/j#;v/a$;D.\" &\"/S$;v/J$;F.\" &\"/<$;v/3$;A/*$8':\xB0'#$\" )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\\#;B/S$2{\"\"6{7|/D$;v/;$;*/2$;v/)$8&:\xB1&\"$!)(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2~\"\"6~7\x7F/\x98#$%;v/:#;J/1$;v/($8#:\xA9#!!)(#'#(\"'#&'#/G#0D*%;v/:#;J/1$;v/($8#:\xA9#!!)(#'#(\"'#&'#&&&#/@$;v/7$2\x81\"\"6\x817\x82/($8$:\xB2$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\x82#;3.\" &\"/t$;v/k$2\xB3\"\"6\xB37\xB4/\\$;v/S$;F.\" &\"/E$;v/<$;K/3$;v/*$8):\xB5)#'#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";N.; &;U.5 &;V./ &;O.) &;R.# &;]"),
    peg$decode("%;v/\x82#;3.\" &\"/t$;v/k$2\xB6\"\"6\xB67\xB7/\\$;v/S$;(/J$;v/A$;F.\" &\"/3$;v/*$8):\xB8)#'#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\x9A#;3.\" &\"/\x8C$;v/\x83$2\xB9\"\"6\xB97\xBA/t$;v/k$;(/b$;v/Y$;F.\" &\"/K$;v/B$;Q.\" &\"/4$;v/+$8+:\xBB+$)%#!)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\xBC\"\"6\xBC7\xBD/C#;v/:$;*/1$;v/($8$:\xBE$!!)($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\x8F#2\x86\"\"6\x867\x87/\x80$;v/w$2\xBC\"\"6\xBC7\xBD.\" &\"/c$;v/Z$;*/Q$;v/H$$;P/&#0#*;P&&&#/2$;v/)$8):\xBF)\"#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\x95#;3.\" &\"/\x87$;v/~$2\xC0\"\"6\xC07\xC1/o$;v/f$;(/]$;v/T$;F.\" &\"/F$;v/=$;S/4$;v/+$8+:\xC2+$)%#!)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2~\"\"6~7\x7F/\x98#$%;v/:#;T/1$;v/($8#:\xA9#!!)(#'#(\"'#&'#/G#0D*%;v/:#;T/1$;v/($8#:\xA9#!!)(#'#(\"'#&'#&&&#/@$;v/7$2\x81\"\"6\x817\x82/($8$:\xC3$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;v/j#;3.\" &\"/\\$;v/S$;(/J$;v/A$;F.\" &\"/3$;v/*$8':\xC4'#%#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\xB2#;3.\" &\"/\xA4$;v/\x9B$2\xC5\"\"6\xC57\xC6/\x8C$;v/\x83$;(/z$;v/q$;\\.\" &\"/c$;v/Z$;F.\" &\"/L$;v/C$;X.\" &\"/5$;v/,$8-:\xC7-%+'%#!)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\xB2#;3.\" &\"/\xA4$;v/\x9B$2\xC8\"\"6\xC87\xC9/\x8C$;v/\x83$;(/z$;v/q$;\\.\" &\"/c$;v/Z$;F.\" &\"/L$;v/C$;X.\" &\"/5$;v/,$8-:\xCA-%+'%#!)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\xAD#;3.\" &\"/\x9F$;v/\x96$;(/\x8D$;v/\x84$;Z.\" &\"/v$;v/m$2{\"\"6{7|/^$;v/U$;,/L$;v/C$;F.\" &\"/5$;v/,$8-:\xCB-%+)'#!)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2~\"\"6~7\x7F/\x89#$%;v/:#;W/1$;v/($8#:\x96#!!)(#'#(\"'#&'#0D*%;v/:#;W/1$;v/($8#:\x96#!!)(#'#(\"'#&'#&/7$2\x81\"\"6\x817\x82/($8#:\xCC#!!)(#'#(\"'#&'#"),
    peg$decode("%;v/\xAD#;3.\" &\"/\x9F$;v/\x96$;(/\x8D$;v/\x84$2{\"\"6{7|/u$;v/l$;,/c$;v/Z$;8.\" &\"/L$;v/C$;F.\" &\"/5$;v/,$8-:\xCD-%+)%#!)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\x8C\"\"6\x8C7\x8D/\x92#$%;v/:#;Y/1$;v/($8#:\x92#!!)(#'#(\"'#&'#0D*%;v/:#;Y/1$;v/($8#:\x92#!!)(#'#(\"'#&'#&/@$;v/7$2\x8E\"\"6\x8E7\x8F/($8$:\x93$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%2\xCE\"\"6\xCE7\xCF/C#;v/:$;*/1$;v/($8$:\xBE$!!)($'#(#'#(\"'#&'#"),
    peg$decode("%2\xD0\"\"6\xD07\xD1/z#;v/q$2\xCE\"\"6\xCE7\xCF.\" &\"/]$;v/T$;*/K$;v/B$$;[0#*;[&/2$;v/)$8(:\xBF(\"#!)(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\x9A#;3.\" &\"/\x8C$;v/\x83$2\xD2\"\"6\xD27\xD3/t$;v/k$;(/b$;v/Y$;F.\" &\"/K$;v/B$;^.\" &\"/4$;v/+$8+:\xD4+$)%#!)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2~\"\"6~7\x7F/\x92#$%;v/:#;Y/1$;v/($8#:\x92#!!)(#'#(\"'#&'#0D*%;v/:#;Y/1$;v/($8#:\x92#!!)(#'#(\"'#&'#&/@$;v/7$2\x81\"\"6\x817\x82/($8$:\x93$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;v/\xD5#;3.\" &\"/\xC7$;v/\xBE$2\xD5\"\"6\xD57\xD6/\xAF$;v/\xA6$2\xA6\"\"6\xA67\xA7/\x97$;(/\x8E$;v/\x85$;Z/|$;v/s$2\xD7\"\"6\xD77\xD8.\" &\"/_$;v/V$2\xA3\"\"6\xA37\xA4/G$;v/>$;a/5$;v/,$80:\xD90%.)'%!)(0'#(/'#(.'#(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%2\xBC\"\"6\xBC7\xBD/C#;v/:$;b/1$;v/($8$:\xBE$!!)($'#(#'#(\"'#&'#"),
    peg$decode("%;v/q#2\xBC\"\"6\xBC7\xBD.\" &\"/]$;v/T$;b/K$;v/B$$;`0#*;`&/2$;v/)$8':\xBF'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";c.# &;d"),
    peg$decode("%2\xDA\"\"6\xDA7\xDB/,#;s/#$+\")(\"'#&'#.\xE3 &%2\xDC\"\"6\xDC7\xDD/,#;s/#$+\")(\"'#&'#.\xC4 &2\xDE\"\"6\xDE7\xDF.\xB8 &%2\xE0\"\"6\xE07\xE1/,#;s/#$+\")(\"'#&'#.\x99 &%2\xE2\"\"6\xE27\xE3/,#;s/#$+\")(\"'#&'#.z &%2\xE4\"\"6\xE47\xE5/,#;s/#$+\")(\"'#&'#.[ &%2\xE6\"\"6\xE67\xE7/,#;s/#$+\")(\"'#&'#.< &%2\xE8\"\"6\xE87\xE9/,#;s/#$+\")(\"'#&'#"),
    peg$decode("%2\xEA\"\"6\xEA7\xEB/,#;s/#$+\")(\"'#&'#.\u0153 &%2\xEC\"\"6\xEC7\xED/,#;s/#$+\")(\"'#&'#.\u0134 &%2\xEE\"\"6\xEE7\xEF/,#;s/#$+\")(\"'#&'#.\u0115 &%2\xF0\"\"6\xF07\xF1/,#;s/#$+\")(\"'#&'#.\xF6 &%2\xF2\"\"6\xF27\xF3/,#;s/#$+\")(\"'#&'#.\xD7 &%2\xF4\"\"6\xF47\xF5/,#;s/#$+\")(\"'#&'#.\xB8 &%2\xF6\"\"6\xF67\xF7/,#;s/#$+\")(\"'#&'#.\x99 &%2\xF8\"\"6\xF87\xF9/,#;s/#$+\")(\"'#&'#.z &%2\xFA\"\"6\xFA7\xFB/,#;s/#$+\")(\"'#&'#.[ &%2\xFC\"\"6\xFC7\xFD/,#;s/#$+\")(\"'#&'#.< &%2\xFE\"\"6\xFE7\xFF/,#;s/#$+\")(\"'#&'#"),
    peg$decode(";g.# &;h"),
    peg$decode("%;v/;#2\u0100\"\"6\u01007\u0101/,$;v/#$+#)(#'#(\"'#&'#"),
    peg$decode("%;f/j#2\xB3\"\"6\xB37\xB4/[$;v/R$;F.\" &\"/D$;v/;$;K/2$;v/)$8':\u0102'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#.\\ &%;f/R#2\xB3\"\"6\xB37\xB4/C$;v/:$;F/1$;v/($8%:\u0103%!!)(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";i.; &;j.5 &;k./ &;l.) &;m.# &;n"),
    peg$decode("%;f/e#2\xB6\"\"6\xB67\xB7/V$;v/M$;(/D$;v/;$;F/2$;v/)$8':\u0104'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;f/\x95#2\xC5\"\"6\xC57\xC6/\x86$;v/}$;(/t$;v/k$;\\.\" &\"/]$;v/T$;F.\" &\"/F$;v/=$;X/4$;v/+$8+:\u0105+$'%#!)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\xD9 &%;f/}#2\xC5\"\"6\xC57\xC6/n$;v/e$;(/\\$;v/S$;\\.\" &\"/E$;v/<$;F/3$;v/*$8):\u0106)#%#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.o &%;f/e#2\xC5\"\"6\xC57\xC6/V$;v/M$;(/D$;v/;$;\\/2$;v/)$8':\u0107'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;f/\x95#2\xC8\"\"6\xC87\xC9/\x86$;v/}$;(/t$;v/k$;\\.\" &\"/]$;v/T$;F.\" &\"/F$;v/=$;X/4$;v/+$8+:\u0108+$'%#!)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\xD9 &%;f/}#2\xC8\"\"6\xC87\xC9/n$;v/e$;(/\\$;v/S$;\\.\" &\"/E$;v/<$;F/3$;v/*$8):\u0109)#%#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.o &%;f/e#2\xC8\"\"6\xC87\xC9/V$;v/M$;(/D$;v/;$;\\/2$;v/)$8':\u010A'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;f/}#2\xB9\"\"6\xB97\xBA/n$;v/e$;(/\\$;v/S$;F.\" &\"/E$;v/<$;Q/3$;v/*$8):\u010B)#%#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.o &%;f/e#2\xB9\"\"6\xB97\xBA/V$;v/M$;(/D$;v/;$;F/2$;v/)$8':\u010C'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;f/}#2\xC0\"\"6\xC07\xC1/n$;v/e$;(/\\$;v/S$;F.\" &\"/E$;v/<$;S/3$;v/*$8):\u010D)#%#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.o &%;f/e#2\xC0\"\"6\xC07\xC1/V$;v/M$;(/D$;v/;$;F/2$;v/)$8':\u010E'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;f/}#2\xD2\"\"6\xD27\xD3/n$;v/e$;(/\\$;v/S$;F.\" &\"/E$;v/<$;^/3$;v/*$8):\u010F)#%#!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.o &%;f/e#2\xD2\"\"6\xD27\xD3/V$;v/M$;(/D$;v/;$;F/2$;v/)$8':\u0110'\"#!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";L.) &;M.# &;_"),
    peg$decode(";C.# &;G"),
    peg$decode(";p.) &;o.# &;e"),
    peg$decode("%$%;v/:#;q/1$;v/($8#:\u0111#!!)(#'#(\"'#&'#0D*%;v/:#;q/1$;v/($8#:\u0111#!!)(#'#(\"'#&'#&/' 8!:\u0112!! )"),
    peg$decode("%<$4\u0113\"\"5!7\u0114/,#0)*4\u0113\"\"5!7\u0114&&&#=.##&&!&'#"),
    peg$decode("4\u0115\"\"5!7\u0116"),
    peg$decode("%<1\"\"5!7 =.##&&!&'#"),
    peg$decode("<%$;t0#*;t&/,#;)/#$+\")(\"'#&'#.6 &$4\u0118\"\"5!7\u01190)*4\u0118\"\"5!7\u0119&=.\" 7\u0117")
  ];

  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected: Expectation[] = [];
  let peg$silentFails = 0;

  let peg$result;

  if (options.startRule !== undefined) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function text(): string {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location(): IFileRange {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description: string, location1?: IFileRange) {
    location1 = location1 !== undefined
      ? location1
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location1
    );
  }

  function error(message: string, location1?: IFileRange) {
    location1 = location1 !== undefined
      ? location1
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location1);
  }

  function peg$literalExpectation(text1: string, ignoreCase: boolean): ILiteralExpectation {
    return { type: "literal", text: text1, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts: IClassParts, inverted: boolean, ignoreCase: boolean): IClassExpectation {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation(): IAnyExpectation {
    return { type: "any" };
  }

  function peg$endExpectation(): IEndExpectation {
    return { type: "end" };
  }

  function peg$otherExpectation(description: string): IOtherExpectation {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos: number) {
    let details = peg$posDetailsCache[pos];
    let p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  function peg$computeLocation(startPos: number, endPos: number): IFileRange {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected1: Expectation) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected1);
  }

  function peg$buildSimpleError(message: string, location1: IFileRange) {
    return new SyntaxError(message, [], "", location1);
  }

  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: IFileRange) {
    return new SyntaxError(
      SyntaxError.buildMessage(expected1, found),
      expected1,
      found,
      location1
    );
  }

  function peg$decode(s: string): number[] {
    return s.split("").map((ch) =>  ch.charCodeAt(0) - 32 );
  }

  function peg$parseRule(index: number): any {
    const bc = peg$bytecode[index];
    let ip = 0;
    const ips: any[] = [];
    let end = bc.length;
    const ends: any[] = [];
    const stack: any[] = [];
    let params;

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;

          case 1:
            stack.push(undefined);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);

              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, (peg$consts[bc[ip + 1]] as string).length) === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, (peg$consts[bc[ip + 1]] as string).length).toLowerCase() === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if ((peg$consts[bc[ip + 1]] as RegExp).test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += (peg$consts[bc[ip + 1]] as string).length;
            ip += 2;
            break;

          case 23:
            stack.push(peg$FAILED);
            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]] as ILiteralExpectation);
            }
            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
              .map(function(p) { return stack[stack.length - 1 - p]; });

            stack.splice(
              stack.length - bc[ip + 2],
              bc[ip + 2],
              (peg$consts[bc[ip + 1]] as ((...args: any[]) => any)).apply(null, params)
            );

            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    return stack[0];
  }

  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

export interface IParseOptions {
  filename?: string;
  startRule?: string;
  tracer?: any;
  [key: string]: any;
}
export type ParseFunction = (input: string, options?: IParseOptions) => any;
export const parse: ParseFunction = peg$parse;

